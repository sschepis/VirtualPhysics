package symmetrical.tooling.codegen

/*
 * This file is part of Virtual Physics.
 *
 * Copyright (C) [2024] Stephen R. DeSofi AKA Eschelon Azha
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import kotlin.reflect.KClass
import kotlin.reflect.full.memberProperties

/**
 * Tool to generate Atom classes from existing Kotlin classes.
 * This generator creates Virtual Physics Atoms based on class properties,
 * enabling easy migration from traditional classes to the Virtual Physics paradigm.
 */
class AtomGenerator {
    
    /**
     * Generates an Atom class definition from a given Kotlin class.
     * 
     * @param kClass The class to generate an Atom from
     * @param packageName Optional custom package name for the generated Atom
     * @return String containing the generated Kotlin code
     */
    fun <T : Any> generateAtom(kClass: KClass<T>, packageName: String = "symmetrical.dictionary.atoms"): String {
        val className = kClass.simpleName ?: "GeneratedAtom"
        val atomClassName = "${className}Atom"
        
        val code = StringBuilder()
        
        // Package declaration
        code.append("package $packageName\n\n")
        
        // Imports
        code.append("import symmetrical.physics.atomic.atoms.elements.Hydrogen\n")
        code.append("import symmetrical.physics.subatomic.luminescent.IMatterAntiMatter\n")
        code.append("import symmetrical.physics.subatomic.luminescent.MatterAntiMatter\n\n")
        
        // Class documentation
        code.append("/**\n")
        code.append(" * Atom representation of $className\n")
        code.append(" * Auto-generated by AtomGenerator\n")
        code.append(" */\n")
        
        // Class declaration
        code.append("class $atomClassName(\n")
        code.append("    private val matterAntiMatter: IMatterAntiMatter = MatterAntiMatter().with($atomClassName::class)\n")
        code.append(") : Hydrogen(), IMatterAntiMatter by matterAntiMatter {\n\n")
        
        // Constructor with value
        code.append("    /**\n")
        code.append("     * Creates a new $atomClassName with the specified value.\n")
        code.append("     */\n")
        code.append("    fun with(value: Any?): $atomClassName {\n")
        code.append("        setAtomicValue(value, true)\n")
        code.append("        return this\n")
        code.append("    }\n")
        
        // Close class
        code.append("}\n")
        
        return code.toString()
    }
    
    /**
     * Generates Atom classes for multiple properties of a class.
     * This is useful when you want to create separate Atoms for each field.
     * 
     * @param kClass The class to analyze
     * @param packageName Optional custom package name
     * @return Map of property names to generated Atom code
     */
    fun <T : Any> generateAtomsFromProperties(
        kClass: KClass<T>, 
        packageName: String = "symmetrical.dictionary.atoms"
    ): Map<String, String> {
        val properties = kClass.memberProperties
        val result = mutableMapOf<String, String>()
        
        for (property in properties) {
            val propertyName = property.name.replaceFirstChar { it.uppercase() }
            val atomName = "${propertyName}Atom"
            
            val code = buildString {
                append("package $packageName\n\n")
                append("import symmetrical.physics.atomic.atoms.elements.Hydrogen\n")
                append("import symmetrical.physics.subatomic.luminescent.IMatterAntiMatter\n")
                append("import symmetrical.physics.subatomic.luminescent.MatterAntiMatter\n\n")
                append("/**\n")
                append(" * Atom for ${kClass.simpleName}.$propertyName property\n")
                append(" * Auto-generated by AtomGenerator\n")
                append(" */\n")
                append("class $atomName(\n")
                append("    private val matterAntiMatter: IMatterAntiMatter = MatterAntiMatter().with($atomName::class)\n")
                append(") : Hydrogen(), IMatterAntiMatter by matterAntiMatter {\n\n")
                append("    fun with(value: Any?): $atomName {\n")
                append("        setAtomicValue(value, true)\n")
                append("        return this\n")
                append("    }\n")
                append("}\n")
            }
            
            result[atomName] = code
        }
        
        return result
    }
    
    /**
     * Generates a usage example for the generated Atom.
     */
    fun <T : Any> generateUsageExample(kClass: KClass<T>): String {
        val className = kClass.simpleName ?: "GeneratedAtom"
        val atomClassName = "${className}Atom"
        
        return buildString {
            append("// Usage example for $atomClassName\n")
            append("val atom = $atomClassName().with(\"example value\")\n\n")
            append("// Data binding example\n")
            append("val atom1 = $atomClassName().with(\"value1\")\n")
            append("val atom2 = $atomClassName().with(\"value2\")\n")
            append("atom1.conductor(atom2) // Two-way binding\n\n")
            append("// Emission example\n")
            append("val emission = atom.emit()\n")
            append("val (clone, _) = Absorber.materialize(emission)\n\n")
            append("// Beta decay (rollback) example\n")
            append("atom.betaPlusDecay(\"new value\")\n")
            append("atom.betaMinusDecay() // Rolls back to previous value\n")
        }
    }
}
