package symmetrical.tooling.codegen

/*
 * This file is part of Virtual Physics.
 *
 * Copyright (C) [2024] Stephen R. DeSofi AKA Eschelon Azha
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import kotlin.reflect.KClass
import kotlin.reflect.KProperty1
import kotlin.reflect.full.memberProperties

/**
 * Tool to generate Molecule classes from existing Kotlin classes.
 * Molecules are compound structures that contain multiple Atoms,
 * similar to traditional data classes with multiple fields.
 */
class MoleculeGenerator {
    
    /**
     * Generates a Molecule class definition from a given Kotlin class.
     * 
     * @param kClass The class to generate a Molecule from
     * @param packageName Optional custom package name for the generated Molecule
     * @return String containing the generated Kotlin code
     */
    fun <T : Any> generateMolecule(kClass: KClass<T>, packageName: String = "symmetrical.dictionary.molecules"): String {
        val className = kClass.simpleName ?: "GeneratedMolecule"
        val moleculeClassName = "${className}Molecule"
        
        val properties = kClass.memberProperties
        
        val code = StringBuilder()
        
        // Package declaration
        code.append("package $packageName\n\n")
        
        // Imports
        code.append("import symmetrical.physics.atomic.substance.molecules.Molecule\n")
        code.append("import symmetrical.physics.atomic.atoms.Atom\n")
        code.append("import symmetrical.physics.subatomic.luminescent.IMatterAntiMatter\n")
        code.append("import symmetrical.physics.subatomic.luminescent.MatterAntiMatter\n")
        code.append("import symmetrical.physics.subatomic.bosons.Photon\n\n")
        
        // Class documentation
        code.append("/**\n")
        code.append(" * Molecule representation of $className\n")
        code.append(" * Contains ${properties.size} atom(s)\n")
        code.append(" * Auto-generated by MoleculeGenerator\n")
        code.append(" */\n")
        
        // Class declaration
        code.append("class $moleculeClassName(\n")
        code.append("    private val matterAntiMatter: IMatterAntiMatter = MatterAntiMatter().with($moleculeClassName::class)\n")
        code.append(") : Molecule(), IMatterAntiMatter by matterAntiMatter {\n\n")
        
        // Atom properties
        properties.forEachIndexed { index, property ->
            val propName = property.name
            code.append("    private var ${propName}Atom: Atom = Atom()\n")
        }
        code.append("\n")
        
        // Constructor method
        code.append("    /**\n")
        code.append("     * Initializes the molecule with values for each atom.\n")
        code.append("     */\n")
        code.append("    fun with(")
        
        properties.forEachIndexed { index, property ->
            if (index > 0) code.append(", ")
            code.append("${property.name}: Any?")
        }
        
        code.append("): $moleculeClassName {\n")
        
        // Bind atoms to molecule
        properties.forEachIndexed { index, property ->
            val propName = property.name
            code.append("        ${propName}Atom.with($propName)\n")
            code.append("        bind(${propName}Atom)\n")
        }
        
        code.append("        return this\n")
        code.append("    }\n\n")
        
        // Getter methods
        properties.forEach { property ->
            val propName = property.name
            val capitalizedName = propName.replaceFirstChar { it.uppercase() }
            code.append("    /**\n")
            code.append("     * Gets the $propName atom.\n")
            code.append("     */\n")
            code.append("    fun get$capitalizedName(): Atom = ${propName}Atom\n\n")
            
            code.append("    /**\n")
            code.append("     * Gets the $propName value.\n")
            code.append("     */\n")
            code.append("    fun get${capitalizedName}Value(): Any? = ${propName}Atom.getContent()\n\n")
        }
        
        // Setter methods
        properties.forEach { property ->
            val propName = property.name
            val capitalizedName = propName.replaceFirstChar { it.uppercase() }
            code.append("    /**\n")
            code.append("     * Sets the $propName value.\n")
            code.append("     */\n")
            code.append("    fun set$capitalizedName(value: Any?): $moleculeClassName {\n")
            code.append("        ${propName}Atom.with(value)\n")
            code.append("        return this\n")
            code.append("    }\n\n")
        }
        
        // Close class
        code.append("}\n")
        
        return code.toString()
    }
    
    /**
     * Generates a usage example for the generated Molecule.
     */
    fun <T : Any> generateUsageExample(kClass: KClass<T>): String {
        val className = kClass.simpleName ?: "GeneratedMolecule"
        val moleculeClassName = "${className}Molecule"
        val properties = kClass.memberProperties.take(3) // Show first 3 properties
        
        return buildString {
            append("// Usage example for $moleculeClassName\n\n")
            
            // Create instance
            append("// Creating a molecule\n")
            append("val molecule = $moleculeClassName().with(\n")
            properties.forEachIndexed { index, prop ->
                if (index > 0) append(",\n")
                append("    ${prop.name} = \"example_${prop.name}\"")
            }
            if (properties.size < kClass.memberProperties.size) {
                append(",\n    ... // additional properties")
            }
            append("\n)\n\n")
            
            // Accessing values
            append("// Accessing atom values\n")
            properties.take(2).forEach { prop ->
                val capitalizedName = prop.name.replaceFirstChar { it.uppercase() }
                append("val ${prop.name} = molecule.get${capitalizedName}Value()\n")
            }
            append("\n")
            
            // Data binding
            append("// Data binding example\n")
            append("val molecule2 = $moleculeClassName()\n")
            if (properties.isNotEmpty()) {
                val firstProp = properties.first().name.replaceFirstChar { it.uppercase() }
                append("molecule.get$firstProp().conductor(molecule2.get$firstProp())\n")
            }
            append("\n")
            
            // Emission
            append("// Serialization example\n")
            append("val emission = molecule.emit()\n")
            append("val (clone, _) = Absorber.materialize(emission)\n")
            append("val moleculeClone = clone as $moleculeClassName\n\n")
            
            // Rollback
            append("// Beta decay (rollback) example\n")
            if (properties.isNotEmpty()) {
                val firstProp = properties.first().name.replaceFirstChar { it.uppercase() }
                append("molecule.get$firstProp().betaPlusDecay(\"new value\")\n")
                append("molecule.get$firstProp().betaMinusDecay() // Rolls back\n")
            }
        }
    }
    
    /**
     * Generates a Compound (complex molecule) from a nested class structure.
     */
    fun <T : Any> generateCompound(kClass: KClass<T>, packageName: String = "symmetrical.dictionary.compounds"): String {
        val className = kClass.simpleName ?: "GeneratedCompound"
        val compoundClassName = "${className}Compound"
        
        return buildString {
            append("package $packageName\n\n")
            append("import symmetrical.physics.atomic.substance.ions.Compound\n")
            append("import symmetrical.physics.subatomic.luminescent.IMatterAntiMatter\n")
            append("import symmetrical.physics.subatomic.luminescent.MatterAntiMatter\n\n")
            append("/**\n")
            append(" * Compound representation of $className\n")
            append(" * Auto-generated by MoleculeGenerator\n")
            append(" */\n")
            append("class $compoundClassName(\n")
            append("    private val matterAntiMatter: IMatterAntiMatter = MatterAntiMatter().with($compoundClassName::class)\n")
            append(") : Compound(), IMatterAntiMatter by matterAntiMatter {\n\n")
            append("    // Add your molecule and atom bindings here\n\n")
            append("}\n")
        }
    }
}
